# Task0
Давайте добавим новую бизнес-функцию в нашу модель данных. Каждый человек хочет видеть персональную скидку, и каждый бизнес хочет быть ближе к клиентам.
Подумайте о персональных скидках для людей с одной стороны и пиццерий с другой. Необходимо создать новую реляционную таблицу (задайте имя person_discounts) со следующими правилами.

Установите атрибут id как первичный ключ (пожалуйста, проверьте столбец id в существующих таблицах и выберите тот же тип данных).
Установите атрибуты person_id и pizzeria_id в качестве внешних ключей для соответствующих таблиц (типы данных должны быть такими же, как для столбцов id в соответствующих родительских таблицах).
Задайте явные имена для ограничений внешнего ключа, используя шаблон fk_{table_name}_{column_name}, например fk_person_discounts_person_id.
Добавьте атрибут discount для хранения значения скидки в процентах. Помните, что значение скидки может быть числом с плавающей точкой (просто используйте тип numericданных). Поэтому, пожалуйста, выберите подходящий тип данных, чтобы охватить эту возможность.


# Task1
На самом деле, мы создали структуру для хранения наших скидок и готовы пойти дальше и заполнить нашу person_discountsтаблицу новыми записями.
Итак, есть таблица person_order, в которой хранится история заказов человека. Пожалуйста, напишите оператор DML ( INSERT INTO ... SELECT ...), который вставляет новые записи в person_discountsтаблицу на основе следующих правил.


Возьмите агрегированное состояние из столбцов person_id и pizzeria_id.


Рассчитайте размер персональной скидки с помощью следующего псевдокода:
if “amount of orders” = 1 then “discount” = 10.5  else if “amount of orders” = 2 then  “discount” = 22 else  “discount” = 30


Чтобы создать первичный ключ для таблицы person_discounts, используйте следующую конструкцию SQL (эта конструкция взята из раздела SQL WINDOW FUNCTION).
... ROW_NUMBER( ) OVER ( ) AS id ...

# Task2
Напишите SQL-выражение, которое возвращает заказы с фактической ценой и ценой со скидкой, примененной для каждого человека в соответствующей пиццерии, отсортированные по имени человека и названию пиццы. Пожалуйста, ознакомьтесь с примерами данных ниже.

| name | pizza_name | price | discount_price | pizzeria_name | 
| ------ | ------ | ------ | ------ | ------ |
| Andrey | cheese pizza | 800 | 624 | Dominos |
| Andrey | mushroom pizza | 1100 | 858 | Dominos |
| ... | ... | ... | ... | ... |

# Task3
На самом деле, нам нужно улучшить согласованность данных с одной стороны и настройку производительности с другой стороны. Пожалуйста, создайте уникальный индекс с несколькими столбцами (с именем idx_person_discounts_unique), который предотвращает дубликаты пар идентификаторов персоны и пиццерии.
После создания нового индекса, пожалуйста, предоставьте любой простой оператор SQL, который показывает доказательство использования индекса (используя EXPLAIN ANALYZE). Пример доказательства приведен ниже:

    ...
    Index Scan using idx_person_discounts_unique on person_discounts
    ...

# Task4
Пожалуйста, добавьте следующие правила ограничений для существующих столбцов таблицы person_discounts.
Столбец person_id не должен иметь значение NULL (используйте имя ограничения ch_nn_person_id);
Столбец pizzeria_id не должен иметь значение NULL (используйте имя ограничения ch_nn_pizzeria_id);
Столбец скидки не должен иметь значение NULL (используйте имя ограничения ch_nn_discount);
По умолчанию значение столбца скидки должно быть равно 0 процентов;
Столбец скидки должен содержать значения в диапазоне от 0 до 100 (используйте имя ограничения ch_range_discount).

# Task5
Чтобы соответствовать политикам управления данными, вам необходимо добавить комментарии для таблицы и столбцов таблицы. Давайте применим эту политику к таблице person_discounts. Пожалуйста, добавьте комментарии на английском или русском языке (на ваше усмотрение), объясняющие, какова бизнес-цель таблицы и всех ее атрибутов.

# Task6
Давайте создадим последовательность базы данных с именем seq_person_discounts(начинающуюся со значения 1) и установим значение по умолчанию для атрибута id таблицы, person_discountsчтобы автоматически брать значение seq_person_discountsкаждый раз. Обратите внимание, что ваш следующий номер последовательности равен 1, в этом случае, пожалуйста, установите фактическое значение для последовательности базы данных на основе формулы "количество строк в таблице person_discounts" + 1. В противном случае вы получите ошибки о нарушении ограничения первичного ключа.


